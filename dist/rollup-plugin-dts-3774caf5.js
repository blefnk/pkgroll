"use strict";var Q=require("module"),X=require("path"),Z=require("magic-string");function ee(n){return n&&typeof n=="object"&&"default"in n?n:{default:n}}function te(n){if(n&&n.__esModule)return n;var e=Object.create(null);return n&&Object.keys(n).forEach(function(t){if(t!=="default"){var i=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,i.get?i:{enumerable:!0,get:function(){return n[t]}})}}),e.default=n,Object.freeze(e)}var S=te(X),re=ee(Z),M=require;function ne(){const n=process.cwd();try{return M.resolve("typescript",{paths:[n]})}catch{throw new Error(`Could not find \`typescript\` in ${n}`)}}var r=M(ne());function ie(n){var e,t;return{...n,compilerOptions:(e=n.compilerOptions)!=null?e:{},respectExternal:(t=n.respectExternal)!=null?t:!1}}const A=".d.ts",R={getCurrentDirectory:()=>r.sys.getCurrentDirectory(),getNewLine:()=>r.sys.newLine,getCanonicalFileName:r.sys.useCaseSensitiveFileNames?n=>n:n=>n.toLowerCase()},se={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:r.ScriptTarget.ESNext},L=new Map,O=(...n)=>process.env.DTS_LOG_CACHE?console.log("[cache]",...n):null;function q([n,e],t){for(O(n),L.set(n,t);n!==e&&n!==S.dirname(n);){if(n=S.dirname(n),O("up",n),L.has(n))return O("has",n);L.set(n,t)}}function $(n,e,t){const i={...se,...e};let s=S.dirname(n),o=[];const l=t||s;if(L.has(l))O("HIT",l);else{O("miss",l);const c=t?S.resolve(process.cwd(),t):r.findConfigFile(s,r.sys.fileExists);if(!c)return{dtsFiles:o,dirName:s,compilerOptions:i};let d=s;s=S.dirname(c);const{config:D,error:x}=r.readConfigFile(c,r.sys.readFile);if(x)return console.error(r.formatDiagnostic(x,R)),{dtsFiles:o,dirName:s,compilerOptions:i};O("tsconfig",D);const a=r.parseJsonConfigFileContent(D,r.sys,s);q(t?[t,t]:[d,s],a)}const{fileNames:f,options:u,errors:m}=L.get(l);return o=f.filter(c=>c.endsWith(A)),m.length?(console.error(r.formatDiagnostics(m,R)),{dtsFiles:o,dirName:s,compilerOptions:i}):{dtsFiles:o,dirName:s,compilerOptions:{...u,...i}}}function oe(n,e,t){const{dtsFiles:i,compilerOptions:s}=$(n,e,t);return r.createProgram([n].concat(Array.from(i)),s,r.createCompilerHost(s,!0))}function ae(n,e,t){const i=[];let s=[],o=new Set,l="",f={};for(let u of n){if(u.endsWith(A))continue;u=S.resolve(u);const m=$(u,e,t);if(m.dtsFiles.forEach(o.add,o),!s.length){s.push(u),{dirName:l,compilerOptions:f}=m;continue}if(m.dirName===l)s.push(u);else{const c=r.createCompilerHost(f,!0),d=r.createProgram(s.concat(Array.from(o)),f,c);i.push(d),s=[u],{dirName:l,compilerOptions:f}=m}}if(s.length){const u=r.createCompilerHost(f,!0),m=r.createProgram(s.concat(Array.from(o)),f,u);i.push(m)}return i}function ce(){let n;try{return{codeFrameColumns:n}=M("@babel/code-frame"),n}catch{try{return{codeFrameColumns:n}=Q.createRequire(typeof document=="undefined"?new(require("url")).URL("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("rollup-plugin-dts-3774caf5.js",document.baseURI).href)("@babel/code-frame"),n}catch{}}}function le(n){const e=n.getSourceFile(),t=e.getLineAndCharacterOfPosition(n.getStart()),i=e.getLineAndCharacterOfPosition(n.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:i.line+1,column:i.character+1}}}function pe(n){const e=ce(),i=n.getSourceFile().getFullText(),s=le(n);return e?`
`+e(i,s,{highlightCode:!0}):`
${s.start.line}:${s.start.column}: \`${n.getFullText().trim()}\``}class g extends Error{constructor(e,t="Syntax not yet supported"){super(`${t}
${pe(e)}`)}}class fe{constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const i of this.sourceFile.statements){const s={start:i.getStart(),end:i.getEnd()};if(r.isEmptyStatement(i)){e.unshift({name:"",exports:[],location:s});continue}if((r.isImportDeclaration(i)||r.isExportDeclaration(i))&&i.moduleSpecifier&&r.isStringLiteral(i.moduleSpecifier)){let{text:c}=i.moduleSpecifier;if(c.startsWith(".")&&(c.endsWith(".d.ts")||c.endsWith(".d.cts")||c.endsWith(".d.mts"))){let d=i.moduleSpecifier.getStart()+1,D=i.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:d,end:D},textBeforeCodeAfter:c.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(r.isModuleDeclaration(i)&&i.body&&r.isModuleBlock(i.body)){for(const c of i.body.statements)if(r.isExportDeclaration(c)&&c.exportClause){if(r.isNamespaceExport(c.exportClause))continue;for(const d of c.exportClause.elements)d.propertyName&&d.propertyName.getText()==d.name.getText()&&e.unshift({name:"",exports:[],location:{start:d.propertyName.getEnd(),end:d.name.getEnd()}})}}if(r.isClassDeclaration(i)?t[i.name.getText()]={type:"class",generics:i.typeParameters}:r.isFunctionDeclaration(i)?t[i.name.getText()]={type:"function"}:r.isInterfaceDeclaration(i)?t[i.name.getText()]={type:"interface",generics:i.typeParameters}:r.isTypeAliasDeclaration(i)?t[i.name.getText()]={type:"type",generics:i.typeParameters}:r.isModuleDeclaration(i)&&r.isIdentifier(i.name)?t[i.name.getText()]={type:"namespace"}:r.isEnumDeclaration(i)&&(t[i.name.getText()]={type:"enum"}),!r.isVariableStatement(i))continue;const{declarations:o}=i.declarationList;if(o.length!==1)continue;const l=o[0],f=l.name.getText();if(!l.initializer||!r.isCallExpression(l.initializer)){t[f]={type:"var"};continue}const u=l.initializer.arguments[0];if(!l.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!r.isObjectLiteralExpression(u))continue;const m=[];for(const c of u.properties){if(!r.isPropertyAssignment(c)||!(r.isIdentifier(c.name)||r.isStringLiteral(c.name))||c.name.text!=="__proto__"&&!r.isIdentifier(c.initializer))throw new g(c,"Expected a property assignment");c.name.text!=="__proto__"&&m.push({exportedName:c.name.text,localName:c.initializer.getText()})}e.unshift({name:f,exports:m,location:s})}return{namespaces:e,itemTypes:t}}fix(){var s;let e=this.sourceFile.getFullText();const{namespaces:t,itemTypes:i}=this.findNamespaces();for(const o of t){const l=e.slice(o.location.end);e=e.slice(0,o.location.start);for(const{exportedName:f,localName:u}of o.exports)if(f===u){const{type:m,generics:c}=i[u]||{};if(m==="interface"||m==="type"){const d=B(c);e+=`type ${o.name}_${f}${d.in} = ${u}${d.out};
`}else if(m==="enum"||m==="class"){const d=B(c);e+=`type ${o.name}_${f}${d.in} = ${u}${d.out};
`,e+=`declare const ${o.name}_${f}: typeof ${u};
`}else e+=`declare const ${o.name}_${f}: typeof ${u};
`}if(o.name){e+=`declare namespace ${o.name} {
`,e+=`  export {
`;for(const{exportedName:f,localName:u}of o.exports)f===u?e+=`    ${o.name}_${f} as ${f},
`:e+=`    ${u} as ${f},
`;e+=`  };
`,e+="}"}e+=(s=o.textBeforeCodeAfter)!=null?s:"",e+=l}return e}}function B(n){return!n||!n.length?{in:"",out:""}:{in:`<${n.map(e=>e.getText()).join(", ")}>`,out:`<${n.map(e=>e.name.getText()).join(", ")}>`}}let U=1;function ue(n){return T({type:"Program",sourceType:"module",body:[]},{start:n.getFullStart(),end:n.getEnd()})}function me(n){const e={type:"Identifier",name:String(U++)};return{ident:e,expr:{type:"AssignmentPattern",left:e,right:n}}}function N(n){return T({type:"Identifier",name:n.getText()},n)}function de(n){const e=T({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},n),t=T({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String(U++)},arguments:[e],optional:!1}},n);return{fn:e,iife:t}}function ye(){const n={type:"ArrayExpression",elements:[]};return{expr:n,stmt:{type:"ReturnStatement",argument:n}}}function he(n,e){return T({type:"FunctionDeclaration",id:T({type:"Identifier",name:r.idText(n)},n),params:[],body:{type:"BlockStatement",body:[]}},e)}function I(n){if(r.isLiteralExpression(n))return{type:"Literal",value:n.text};if(r.isPropertyAccessExpression(n)){if(r.isPrivateIdentifier(n.name))throw new g(n.name);return T({type:"MemberExpression",computed:!1,optional:!1,object:I(n.expression),property:I(n.name)},{start:n.expression.getStart(),end:n.name.getEnd()})}if(r.isIdentifier(n))return N(n);if(n.kind==r.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new g(n)}function T(n,e){let t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(n,t)}function K(n,e){return(r.getCombinedModifierFlags(n)&e)===e}function ge({sourceFile:n}){const e=new re.default(n.getFullText()),t=new Set,i=new Set;let s="";const o=new Map,l=new Map;for(const a of n.statements){if(r.isEmptyStatement(a)){e.remove(a.getStart(),a.getEnd());continue}if(r.isEnumDeclaration(a)||r.isFunctionDeclaration(a)||r.isInterfaceDeclaration(a)||r.isClassDeclaration(a)||r.isTypeAliasDeclaration(a)||r.isModuleDeclaration(a)){if(a.name){const p=a.name.getText();t.add(p),K(a,r.ModifierFlags.ExportDefault)?s=p:K(a,r.ModifierFlags.Export)&&i.add(p),a.flags&r.NodeFlags.GlobalAugmentation||x(p,[_(a),H(a)])}r.isModuleDeclaration(a)&&xe(e,a),W(e,a)}else if(r.isVariableStatement(a)){const{declarations:p}=a.declarationList,y=K(a,r.ModifierFlags.Export);for(const v of a.declarationList.declarations)if(r.isIdentifier(v.name)){const E=v.name.getText();t.add(E),y&&i.add(E)}if(W(e,a),p.length==1){const v=p[0];r.isIdentifier(v.name)&&x(v.name.getText(),[_(a),H(a)])}else{const v=p.slice(),E=v.shift();x(E.name.getText(),[_(a),E.getEnd()]);for(const C of v)r.isIdentifier(C.name)&&x(C.name.getText(),[C.getFullStart(),C.getEnd()])}const{flags:h}=a.declarationList,F=`declare ${h&r.NodeFlags.Let?"let":h&r.NodeFlags.Const?"const":"var"} `,P=a.declarationList.getChildren().find(v=>v.kind===r.SyntaxKind.SyntaxList).getChildren();let w=0;for(const v of P)if(v.kind===r.SyntaxKind.CommaToken)w=v.getStart(),e.remove(w,v.getEnd());else if(w){e.appendLeft(w,`;
`);const E=v.getFullStart(),C=e.slice(E,v.getStart());let z=C.length-C.trimStart().length;z?e.overwrite(E,E+z,F):e.appendLeft(E,F)}}}for(const a of n.statements)if(c(a),!!K(a,r.ModifierFlags.ExportDefault)&&(r.isFunctionDeclaration(a)||r.isClassDeclaration(a))){if(a.name)continue;s||(s=D("export_default"));const p=a.getChildren(),y=p.findIndex(P=>P.kind===r.SyntaxKind.ClassKeyword||P.kind===r.SyntaxKind.FunctionKeyword),h=p[y],b=p[y+1];b.kind>=r.SyntaxKind.FirstPunctuation&&b.kind<=r.SyntaxKind.LastPunctuation?e.appendLeft(b.getStart(),s):e.appendRight(h.getEnd(),` ${s}`)}for(const a of l.values()){const y=a.pop()[0];for(const h of a)e.move(h[0],h[1],y)}s&&e.append(`
export default ${s};
`),i.size&&e.append(`
export { ${[...i].join(", ")} };
`);for(const[a,p]of o.entries())e.prepend(`import * as ${p} from "${a}";
`);const f=n.getLineStarts(),u=new Set;for(const a of n.typeReferenceDirectives){u.add(a.fileName);const{line:p}=n.getLineAndCharacterOfPosition(a.pos),y=f[p];let h=n.getLineEndOfPosition(a.pos);e.slice(h,h+1)==`
`&&(h+=1),e.remove(y,h)}const m=new Set;for(const a of n.referencedFiles){m.add(a.fileName);const{line:p}=n.getLineAndCharacterOfPosition(a.pos),y=f[p];let h=n.getLineEndOfPosition(a.pos);e.slice(h,h+1)==`
`&&(h+=1),e.remove(y,h)}return{code:e,typeReferences:u,fileReferences:m};function c(a){if(r.forEachChild(a,c),r.isImportTypeNode(a)){if(!r.isLiteralTypeNode(a.argument)||!r.isStringLiteral(a.argument.literal))throw new g(a,"inline imports should have a literal argument");const p=a.argument.literal.text,y=a.getChildren(),h=y.find(w=>w.kind===r.SyntaxKind.ImportKeyword).getStart();let b=a.getEnd();const F=y.find(w=>w.kind===r.SyntaxKind.DotToken||w.kind===r.SyntaxKind.LessThanToken);F&&(b=F.getStart());const P=d(p);e.overwrite(h,b,P)}}function d(a){let p=o.get(a);return p||(p=D(a.replace(/[^a-zA-Z0-9_$]/g,()=>"_")),o.set(a,p)),p}function D(a){let p=a;for(;t.has(p);)p=`_${p}`;return t.add(p),p}function x(a,p){let y=l.get(a);if(!y)y=[p],l.set(a,y);else{const h=y[y.length-1];h[1]===p[0]?h[1]=p[1]:y.push(p)}}}function W(n,e){var s;let t=!1;const i=r.isClassDeclaration(e)||r.isFunctionDeclaration(e)||r.isModuleDeclaration(e)||r.isVariableStatement(e);for(const o of(s=e.modifiers)!=null?s:[])switch(o.kind){case r.SyntaxKind.ExportKeyword:case r.SyntaxKind.DefaultKeyword:n.remove(o.getStart(),o.getEnd()+1);break;case r.SyntaxKind.DeclareKeyword:t=!0}i&&!t&&n.appendRight(e.getStart(),"declare ")}function xe(n,e){if(!(!e.body||!r.isModuleBlock(e.body))){for(const t of e.body.statements)if(r.isExportDeclaration(t)&&t.exportClause){if(r.isNamespaceExport(t.exportClause))continue;for(const i of t.exportClause.elements)i.propertyName||n.appendLeft(i.name.getEnd(),` as ${i.name.getText()}`)}}}function _(n){const e=n.getFullStart();return e+(G(n,e)?1:0)}function H(n){const e=n.getEnd();return e+(G(n,e)?1:0)}function G(n,e){return n.getSourceFile().getFullText()[e]==`
`}const Se=new Set([r.SyntaxKind.LiteralType,r.SyntaxKind.VoidKeyword,r.SyntaxKind.UnknownKeyword,r.SyntaxKind.AnyKeyword,r.SyntaxKind.BooleanKeyword,r.SyntaxKind.NumberKeyword,r.SyntaxKind.StringKeyword,r.SyntaxKind.ObjectKeyword,r.SyntaxKind.NullKeyword,r.SyntaxKind.UndefinedKeyword,r.SyntaxKind.SymbolKeyword,r.SyntaxKind.NeverKeyword,r.SyntaxKind.ThisKeyword,r.SyntaxKind.ThisType,r.SyntaxKind.BigIntKeyword]);class J{constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=he(e,t);else{const{iife:s,fn:o}=de(t);this.iife=s,this.declaration=o}const i=ye();this.declaration.body.body.push(i.stmt),this.returnExpr=i.expr}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){var i;const t=e.getText();(i=this.scopes[this.scopes.length-1])==null||i.add(t)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const o of this.scopes)if(o.has(t))return}const{ident:i,expr:s}=me(e);this.declaration.params.push(s),this.returnExpr.elements.push(i)}pushIdentifierReference(e){this.pushReference(N(e))}convertEntityName(e){return r.isIdentifier(e)?N(e):T({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:N(e.right)},e)}convertPropertyAccess(e){if(!r.isIdentifier(e.expression)&&!r.isPropertyAccessExpression(e.expression))throw new g(e.expression);if(r.isPrivateIdentifier(e.name))throw new g(e.name);let t=r.isIdentifier(e.expression)?N(e.expression):this.convertPropertyAccess(e.expression);return T({type:"MemberExpression",computed:!1,optional:!1,object:t,property:N(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!r.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!(r.isLiteralExpression(t)||r.isPrefixUnaryExpression(t))){if(r.isIdentifier(t))return this.pushReference(N(t));if(r.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new g(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const i of e.parameters)this.convertTypeNode(i.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const i of t.types)this.pushReference(I(i.expression)),this.convertTypeArguments(i)}convertTypeArguments(e){if(e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(r.isPropertyDeclaration(t)||r.isPropertySignature(t)||r.isIndexSignatureDeclaration(t)){r.isPropertyDeclaration(t)&&t.initializer&&r.isPropertyAccessExpression(t.initializer)&&this.pushReference(this.convertPropertyAccess(t.initializer)),this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(r.isMethodDeclaration(t)||r.isMethodSignature(t)||r.isConstructorDeclaration(t)||r.isConstructSignatureDeclaration(t)||r.isCallSignatureDeclaration(t)||r.isGetAccessorDeclaration(t)||r.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new g(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(e&&!Se.has(e.kind)){if(r.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(r.isTypeLiteralNode(e))return this.convertMembers(e.members);if(r.isArrayTypeNode(e))return this.convertTypeNode(e.elementType);if(r.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(r.isNamedTupleMember(e)||r.isParenthesizedTypeNode(e)||r.isTypeOperatorNode(e)||r.isTypePredicateNode(e))return this.convertTypeNode(e.type);if(r.isUnionTypeNode(e)||r.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(r.isMappedTypeNode(e)){const{typeParameter:t,type:i,nameType:s}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(i),s&&this.convertTypeNode(s),this.popScope();return}if(r.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(r.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(r.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(r.isTypeQueryNode(e)){this.pushReference(this.convertEntityName(e.exprName));return}if(r.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(r.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(r.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(r.isInferTypeNode(e)){const{typeParameter:t}=e;this.convertTypeNode(t.constraint),this.pushTypeVariable(t.name);return}else throw new g(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&r.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!r.isModuleBlock(e.body))throw new g(e,'namespace must have a "ModuleBlock" body.');const{statements:i}=e.body;for(const s of i){if(r.isEnumDeclaration(s)||r.isFunctionDeclaration(s)||r.isClassDeclaration(s)||r.isInterfaceDeclaration(s)||r.isTypeAliasDeclaration(s)||r.isModuleDeclaration(s)){if(s.name&&r.isIdentifier(s.name))this.pushTypeVariable(s.name);else throw new g(s,"non-Identifier name not supported");continue}if(r.isVariableStatement(s)){for(const o of s.declarationList.declarations)if(r.isIdentifier(o.name))this.pushTypeVariable(o.name);else throw new g(o,"non-Identifier name not supported");continue}if(!r.isExportDeclaration(s))throw new g(s,"namespace child (hoisting) not supported yet")}for(const s of i){if(r.isVariableStatement(s)){for(const o of s.declarationList.declarations)o.type&&this.convertTypeNode(o.type);continue}if(r.isFunctionDeclaration(s)){this.convertParametersAndType(s);continue}if(r.isInterfaceDeclaration(s)||r.isClassDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertHeritageClauses(s),this.convertMembers(s.members),this.popScope(o);continue}if(r.isTypeAliasDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertTypeNode(s.type),this.popScope(o);continue}if(r.isModuleDeclaration(s)){this.convertNamespace(s,t);continue}if(!r.isEnumDeclaration(s))if(r.isExportDeclaration(s)){if(s.exportClause){if(r.isNamespaceExport(s.exportClause))throw new g(s.exportClause);for(const o of s.exportClause.elements){const l=o.propertyName||o.name;this.pushIdentifierReference(l)}}}else throw new g(s,"namespace child (walking) not supported yet")}this.popScope()}}function ve({sourceFile:n}){return new Te(n).transform()}class Te{constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=ue(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const i={start:e.getFullStart(),end:e.getEnd()};if(!t){const f=new J({range:i});return this.pushStatement(f.iife),f}const s=t.getText(),o=new J({id:t,range:i}),l=this.declarations.get(s);if(l){l.pushIdentifierReference(t),l.declaration.end=i.end;let f=this.ast.body.findIndex(u=>u==l.declaration);for(let u=f+1;u<this.ast.body.length;u++){const m=this.ast.body[u];m.start=m.end=i.end}}else this.pushStatement(o.declaration),this.declarations.set(s,o);return l||o}convertStatement(e){if(r.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(r.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(r.isInterfaceDeclaration(e)||r.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(r.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(r.isVariableStatement(e))return this.convertVariableStatement(e);if(r.isExportDeclaration(e)||r.isExportAssignment(e))return this.convertExportDeclaration(e);if(r.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind==r.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(r.isImportDeclaration(e)||r.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new g(e)}removeStatement(e){this.pushStatement(T({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&r.NodeFlags.GlobalAugmentation||!r.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const i=this.createDeclaration(e,e.name);i.pushIdentifierReference(e.name),i.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new g(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new g(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),i=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(i)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),i=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(i)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new g(e,"VariableStatement with more than one declaration not yet supported");for(const i of t){if(!r.isIdentifier(i.name))throw new g(e,"VariableDeclaration must have a name");this.createDeclaration(e,i.name).convertTypeNode(i.type)}}convertExportDeclaration(e){if(r.isExportAssignment(e)){this.pushStatement(T({type:"ExportDefaultDeclaration",declaration:I(e.expression)},e));return}const t=e.moduleSpecifier?I(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(T({type:"ExportAllDeclaration",source:t,exported:null},e));else if(r.isNamespaceExport(e.exportClause))this.pushStatement(T({type:"ExportAllDeclaration",source:t,exported:N(e.exportClause.name)},e));else{const i=[];for(const s of e.exportClause.elements)i.push(this.convertExportSpecifier(s));this.pushStatement(T({type:"ExportNamedDeclaration",declaration:null,specifiers:i,source:t},e))}}convertImportDeclaration(e){if(r.isImportEqualsDeclaration(e)){if(!r.isExternalModuleReference(e.moduleReference))throw new g(e,"ImportEquals should have a literal source.");this.pushStatement(T({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:N(e.name)}],source:I(e.moduleReference.expression)},e));return}const t=I(e.moduleSpecifier),i=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&i.push({type:"ImportDefaultSpecifier",local:N(e.importClause.name)}),this.pushStatement(T({type:"ImportDeclaration",specifiers:i,source:t},e))}convertNamedImportBindings(e){return r.isNamedImports(e)?e.elements.map(t=>{const i=N(t.name),s=t.propertyName?N(t.propertyName):i;return{type:"ImportSpecifier",local:i,imported:s}}):[{type:"ImportNamespaceSpecifier",local:N(e.name)}]}convertExportSpecifier(e){const t=N(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?N(e.propertyName):t}}}function k(n,e){return r.createSourceFile(n,e,r.ScriptTarget.Latest,!0)}const Ne=()=>{const n=new Map,e=new Map;return{name:"dts-transform",options(t){const{onwarn:i}=t;return{...t,onwarn(s,o){s.code!="CIRCULAR_DEPENDENCY"&&(i?i(s,o):o(s))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}}},outputOptions(t){return{...t,chunkFileNames:t.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:t.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:"esModule",generatedCode:Object.assign({symbols:!1},t.generatedCode),strict:!1}},transform(t,i){let s=k(i,t);const o=ge({sourceFile:s});n.set(s.fileName,o.typeReferences),e.set(s.fileName,o.fileReferences),t=o.code.toString(),s=k(i,t);const l=ve({sourceFile:s});return process.env.DTS_DUMP_AST&&(console.log(i),console.log(t),console.log(JSON.stringify(l.ast.body,void 0,2))),{code:t,ast:l.ast,map:o.code.generateMap()}},renderChunk(t,i,s){const o=k(i.fileName,t),l=new fe(o),f=new Set,u=new Set;for(const m of Object.keys(i.modules)){for(const c of n.get(m.split("\\").join("/"))||[])f.add(c);for(const c of e.get(m.split("\\").join("/"))||[])if(c.startsWith(".")){const d=S.join(S.dirname(m),c),D=s.file&&S.dirname(s.file)||i.facadeModuleId&&S.dirname(i.facadeModuleId)||".";let x=S.relative(D,d).split("\\").join("/");x[0]!=="."&&(x="./"+x),u.add(x)}else u.add(c)}return t=Y(Array.from(u,m=>`/// <reference path="${m}" />`)),t+=Y(Array.from(f,m=>`/// <reference types="${m}" />`)),t+=l.fix(),t||(t+=`
export { }`),{code:t,map:{mappings:""}}}}};function Y(n){return n.length?n.join(`
`)+`
`:""}const j=/\.([cm]ts|[tj]sx?)$/;function V({programs:n,resolvedOptions:{compilerOptions:e,tsconfig:t}},i,s){if(!n.length&&i.endsWith(A))return{code:s};const o=n.find(l=>!!l.getSourceFile(i));if(o){const l=o.getSourceFile(i);return{code:l.getFullText(),source:l,program:o}}else if(r.sys.fileExists(i)){const l=oe(i,e,t);n.push(l);const f=l.getSourceFile(i);return{code:f.getFullText(),source:f,program:l}}else return null}function De(n={}){const e=Ne(),t={programs:[],resolvedOptions:ie(n)};return{name:"dts",outputOptions:e.outputOptions,renderChunk:e.renderChunk,options(i){let{input:s=[]}=i;if(!Array.isArray(s))s=typeof s=="string"?[s]:Object.values(s);else if(s.length>1){i.input={};for(const o of s){let l=o.replace(/((\.d)?\.(t|j)sx?)$/,"");S.isAbsolute(o)?l=S.basename(l):l=S.normalize(l),i.input[l]=o}}return t.programs=ae(Object.values(s),t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig),e.options.call(this,i)},transform(i,s){var m;if(!j.test(s))return null;const o=c=>{if(c.program){const d=S.dirname(s);c.program.getSourceFiles().map(x=>x.fileName).filter(x=>x.startsWith(d)).forEach(this.addWatchFile)}},l=()=>{const c=V(t,s,i);return c?(o(c),e.transform.call(this,c.code,s)):null},f=()=>{const c=s.replace(j,A);let d=V(t,c,i);return d?(o(d),e.transform.call(this,d.code,c)):null},u=()=>{const c=V(t,s,i);if(!c||!c.source||!c.program)return null;o(c);const d=s.replace(j,A);let D;const{emitSkipped:x,diagnostics:a}=c.program.emit(c.source,(p,y)=>{D=e.transform.call(this,y,d)},void 0,!0);if(x){const p=a.filter(y=>y.category===r.DiagnosticCategory.Error);p.length&&(console.error(r.formatDiagnostics(p,R)),this.error("Failed to compile. Check the logs above."))}return D};return s.endsWith(A)?l():(m=f())!=null?m:u()},resolveId(i,s){if(!s)return;s=s.split("\\").join("/");let o=t.resolvedOptions.compilerOptions;if(t.resolvedOptions.tsconfig){const f=i.startsWith(".")?S.resolve(S.dirname(s),i):i;o=$(f,t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig).compilerOptions}const{resolvedModule:l}=r.nodeModuleNameResolver(i,s,o,r.sys);if(l)return!t.resolvedOptions.respectExternal&&l.isExternalLibraryImport?{id:i,external:!0}:{id:S.resolve(l.resolvedFileName)}}}}exports.default=De;
